#!/usr/bin/env bash

set -euo pipefail

# setup directory
GIT_CONFIG_ROOT=$(dirname "$(git config --global --get include.path)")

# setup defaults message for cron tasks
DEFAULT_MESSAGE="chores"
DEFAULT_PS="cron"
CURRTIME=$(date +%s)

# setup message files
MSG_FILE="$GIT_CONFIG_ROOT/dot-commit-msg"
PID_FILE="/tmp/autodots.pid"
BACKUP_DIR="/mnt/Centralized/documents/dotfiles"

# get datetime
COMMITTIME=$(date +'%m/%d %H:%M%p')
TASKNAME=
MESSAGE=
INTERACTIVE=

echo $$ >| $PID_FILE

check_interactive() {
  case "$-" in
    *i*)
      # this is interactive
      INTERACTIVE=0
      ;;
    *)
      INTERACTIVE=1
      ;;
  esac
}

function pprint() {
  if [[ $INTERACTIVE == 0 ]]; then
    echo -e "$*"
  else
    # cyan
    echo -e "\e[1;33m$*\e[m"
  fi
}

# check if message files is recently modified, default time difference: 20h
# https://stackoverflow.com/a/28341234/8643197
check_if_modified(){

  file=$1

  [[ ! -f $file ]] && touch "$file"
  STALE=$(expr 20 \* 60 \* 60 )
  {{- if eq .chezmoi.os "linux" }}
  FILETIME=$(stat "$file" -c %Y)
  {{- else if eq .chezmoi.os "darwin" }}
  FILETIME=$(stat -t %s -f %m $file)
  {{- end }}

  if [ $(expr "$CURRTIME" - "$FILETIME" ) -lt "$STALE" ]; then
    return 0
  else
    return 1
  fi
}

define_message_body(){

  # this will handles while interactive, check predefined message, or just use chores
  if check_if_modified $MSG_FILE; then
    pprint "Using predefined message, stored at $MSG_FILE"
    MESSAGE=$(cat "$MSG_FILE")
  elif [[ $INTERACTIVE == 1 ]]; then
    read -ep "Define message: " MESSAGE
    TASKNAME="user"
  else
    MESSAGE=$DEFAULT_MESSAGE
  fi

  if [[ -z $TASKNAME ]]; then
    TASKNAME=$DEFAULT_PS
  fi

}

# https://stackoverflow.com/a/36332260/8643197
# TODO: should only run as cronjob instead of scripts
backup_dotfiles() {
  BACKUPDIR="$1"
  [[ -d "$BACKUPDIR" ]] || git clone git@github.com:aarnphm/dotfiles.git $BACKUPDIR 
  cd "$BACKUPDIR" && git fetch && git pull --recurse-submodules
}

autopush_dots() {

  # this will check whether task is running by cron or user
  check_interactive

  # backup
  pprint "Backup dotfiles to $BACKUP_DIR..."
  backup_dotfiles $BACKUP_DIR

  # define message block here
  pprint "\nGet commit message..."
  define_message_body && cd "$(chezmoi source-path)"
  if [[ $INTERACTIVE == 1 ]]; then
    COMMITMSG="[$TASKNAME] $COMMITTIME: $MESSAGE"
    pprint "Commit message: $COMMITMSG"
  fi

  pprint "\nDumping installed packages to files..."
  {{- if eq .chezmoi.os "linux" }}
  # Check for new packages, and add it to both .local file
  yay -Qqen >| {{ .chezmoi.sourceDir }}/bootstrap/configs/Pacfile.local
  yay -Qqem >| {{ .chezmoi.sourceDir }}/bootstrap/configs/Aurfile.local
  {{- else }}
  brew bundle dump --file={{ .chezmoi.sourceDir }}/bootstrap/configs/Brewfile
  {{- end }}

  # Check if upstream, else not pull
  if [ $(git rev-parse @) == $(git merge-base @ ${1:-'@{u}'}) ]; then
    git pull --recurse-submodules
  fi

  # execute scripts
  pprint "\nPushing to remote directory..."
  git add -f -v . && git commit -am "$COMMITMSG" && git push --all
}

autopush_dots "$@"
# vim: set ft=zsh.gohtmltmpl ts=2 sw=2 tw=0 et :
